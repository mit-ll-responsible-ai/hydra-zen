
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydra_zen.structured_configs._implementations &#8212; hydra-zen 0.3.0rc4+1.gb2d64d7 documentation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/blank.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/my_theme.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/hydra_zen_favicon_32x32.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="32x32" href="../../../_static/../../brand/hydra_zen_favicon_32x32.ico">
      
    
      
      <link rel="icon" sizes="64x64" href="../../../_static/../../brand/hydra_zen_favicon_64x64.ico">
      
    
      
      <link rel="icon" sizes="134x134" href="../../../_static/../../brand/hydra_zen_favicon.ico">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/Hydra-Zen_logo_full_filled_bkgrnd_smaller.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../installation.html">
  Installation and Basic Usage
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../overview.html">
  Overview of hydra-zen
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../pytorch_lightning_example.html">
  Boilerplate-Free ML: An Example Using hydra-zen and PyTorch Lightning
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../structured_configs.html">
  Dynamically Generating Structured Configs
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../experimental.html">
  Running Experiments with Hydra
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api_reference.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../changes.html">
  Changelog
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/mit-ll-responsible-ai/hydra-zen" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for hydra_zen.structured_configs._implementations</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2021 Massachusetts Institute of Technology</span>
<span class="c1"># SPDX-License-Identifier: MIT</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">is_dataclass</span><span class="p">,</span> <span class="n">make_dataclass</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">FrozenSet</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">get_type_hints</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">TypeGuard</span>

<span class="kn">from</span> <span class="nn">hydra_zen.errors</span> <span class="kn">import</span> <span class="n">HydraZenDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">hydra_zen.funcs</span> <span class="kn">import</span> <span class="n">get_obj</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">zen_processing</span>
<span class="kn">from</span> <span class="nn">hydra_zen.structured_configs</span> <span class="kn">import</span> <span class="n">_utils</span>
<span class="kn">from</span> <span class="nn">hydra_zen.typing</span> <span class="kn">import</span> <span class="n">Builds</span><span class="p">,</span> <span class="n">Importable</span><span class="p">,</span> <span class="n">Just</span><span class="p">,</span> <span class="n">PartialBuilds</span>
<span class="kn">from</span> <span class="nn">hydra_zen.typing._implementations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DataClass</span><span class="p">,</span>
    <span class="n">HasPartialTarget</span><span class="p">,</span>
    <span class="n">HasTarget</span><span class="p">,</span>
    <span class="n">_DataClass</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># used to check if default values are ufuncs</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ufunc</span>  <span class="c1"># type: ignore</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">ufunc</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T&quot;</span><span class="p">)</span>
<span class="n">_T2</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T2&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Callable</span><span class="p">)</span>
<span class="n">ZenWrapper</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="kc">None</span><span class="p">,</span>
    <span class="n">Builds</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">_T2</span><span class="p">],</span> <span class="n">_T2</span><span class="p">]],</span>
    <span class="n">PartialBuilds</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">_T2</span><span class="p">],</span> <span class="n">_T2</span><span class="p">]],</span>
    <span class="n">Just</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">_T2</span><span class="p">],</span> <span class="n">_T2</span><span class="p">]],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">_T2</span><span class="p">],</span> <span class="n">_T2</span><span class="p">],</span>
    <span class="nb">str</span><span class="p">,</span>
<span class="p">]</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ZenWrapper</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ZenWrapper</span><span class="p">]]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ZenWrappers&quot;</span><span class="p">)</span>

<span class="c1"># Hydra-specific fields</span>
<span class="n">_TARGET_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_target_&quot;</span>
<span class="n">_RECURSIVE_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_recursive_&quot;</span>
<span class="n">_CONVERT_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_convert_&quot;</span>
<span class="n">_POS_ARG_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_args_&quot;</span>

<span class="n">_HYDRA_FIELD_NAMES</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
    <span class="p">(</span>
        <span class="n">_TARGET_FIELD_NAME</span><span class="p">,</span>
        <span class="n">_RECURSIVE_FIELD_NAME</span><span class="p">,</span>
        <span class="n">_CONVERT_FIELD_NAME</span><span class="p">,</span>
        <span class="n">_POS_ARG_FIELD_NAME</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1"># hydra-zen-specific fields</span>
<span class="n">_ZEN_PROCESSING_LOCATION</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">zen_processing</span><span class="p">)</span>
<span class="n">_ZEN_TARGET_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_zen_target&quot;</span>
<span class="n">_PARTIAL_TARGET_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_zen_partial&quot;</span>
<span class="n">_META_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_zen_exclude&quot;</span>
<span class="n">_ZEN_WRAPPERS_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_zen_wrappers&quot;</span>
<span class="n">_JUST_FIELD_NAME</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;path&quot;</span>
<span class="c1"># TODO: add _JUST_Target</span>

<span class="c1"># signature param-types</span>
<span class="n">_POSITIONAL_ONLY</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
<span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="n">_VAR_POSITIONAL</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
<span class="n">_KEYWORD_ONLY</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="n">_VAR_KEYWORD</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>

<span class="n">_builtin_function_or_method_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_target</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_TARGET_FIELD_NAME</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_target_as_kwarg_deprecation</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">_T2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_T2</span><span class="p">]:</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">and</span> <span class="s2">&quot;target&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># builds(target=&lt;&gt;, ...) is deprecated</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">HydraZenDeprecationWarning</span><span class="p">(</span>
                    <span class="s2">&quot;Specifying the target of `builds` as a keyword argument is deprecated &quot;</span>
                    <span class="s2">&quot;as of 2021-09-18. Change `builds(target=&lt;target&gt;, ...)` to `builds(&lt;target&gt;, ...)`.&quot;</span>
                    <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">This will be an error in hydra-zen 1.0.0, or by 2021-12-18 — whichever &quot;</span>
                    <span class="s2">&quot;comes first.</span><span class="se">\n\n</span><span class="s2">Note: This deprecation does not impact yaml configs &quot;</span>
                    <span class="s2">&quot;produced by `builds`.&quot;</span>
                <span class="p">),</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;target&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>


<span class="k">def</span> <span class="nf">_hydra_partial_deprecation</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">_T2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_T2</span><span class="p">]:</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;hydra_partial&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;zen_partial&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Both `hydra_partial` and `zen_partial` are specified. &quot;</span>
                    <span class="s2">&quot;Specifying `hydra_partial` is deprecated, use `zen_partial` &quot;</span>
                    <span class="s2">&quot;instead.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># builds(..., hydra_partial=...) is deprecated</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">HydraZenDeprecationWarning</span><span class="p">(</span>
                    <span class="s2">&quot;The argument `hydra_partial` is deprecated as of 2021-10-10.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Change `builds(..., hydra_partial=&lt;..&gt;)` to `builds(..., zen_partial=&lt;..&gt;)`.&quot;</span>
                    <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">This will be an error in hydra-zen 1.0.0, or by 2022-01-10 — whichever &quot;</span>
                    <span class="s2">&quot;comes first.</span><span class="se">\n\n</span><span class="s2">Note: This deprecation does not impact yaml configs &quot;</span>
                    <span class="s2">&quot;produced by `builds`.&quot;</span>
                <span class="p">),</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;zen_partial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;hydra_partial&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>


<span class="k">def</span> <span class="nf">mutable_value</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">_T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Used to set a mutable object as a default value for a field</span>
<span class="sd">    in a dataclass.</span>

<span class="sd">    This is an alias for ``field(default_factory=lambda: type(x)(x))``</span>

<span class="sd">    Note that ``type(x)(...)`` serves to make a copy</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from hydra_zen import mutable_value</span>
<span class="sd">    &gt;&gt;&gt; from dataclasses import dataclass</span>

<span class="sd">    See https://docs.python.org/3/library/dataclasses.html#mutable-default-values</span>

<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class HasMutableDefault:</span>
<span class="sd">    ...     a_list: list  = [1, 2, 3]  # error: mutable default</span>

<span class="sd">    Using `mutable_value` to specify the default list:</span>

<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class HasMutableDefault:</span>
<span class="sd">    ...     a_list: list  = mutable_value([1, 2, 3])  # ok</span>

<span class="sd">    &gt;&gt;&gt; x = HasMutableDefault()</span>
<span class="sd">    &gt;&gt;&gt; x.a_list.append(-1)  # does not append to `HasMutableDefault.a_list`</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    HasMutableDefault(a_list=[1, 2, 3, -1])</span>
<span class="sd">    &gt;&gt;&gt; HasMutableDefault()</span>
<span class="sd">    HasMutableDefault(a_list=[1, 2, 3])&quot;&quot;&quot;</span>
    <span class="n">cast</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># ensure that we return a copy of the default value</span>
    <span class="k">return</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="n">Field_Entry</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">Field</span><span class="p">]</span>


<span class="c1"># Alternate form, from PEP proposal:</span>
<span class="c1"># https://github.com/microsoft/pyright/blob/master/specs/dataclass_transforms.md</span>
<span class="c1">#</span>
<span class="c1"># This enables static checkers to work with third-party decorators that create</span>
<span class="c1"># dataclass-like objects</span>
<span class="k">def</span> <span class="nf">__dataclass_transform__</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">eq_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">order_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">kw_only_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">field_descriptors</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(()),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">_T</span><span class="p">],</span> <span class="n">_T</span><span class="p">]:</span>
    <span class="c1"># If used within a stub file, the following implementation can be</span>
    <span class="c1"># replaced with &quot;...&quot;.</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span>


<div class="viewcode-block" id="hydrated_dataclass"><a class="viewcode-back" href="../../../generated/hydra_zen.hydrated_dataclass.html#hydra_zen.hydrated_dataclass">[docs]</a><span class="nd">@__dataclass_transform__</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">hydrated_dataclass</span><span class="p">(</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="o">*</span><span class="n">pos_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">zen_partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">zen_wrappers</span><span class="p">:</span> <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="n">zen_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">populate_full_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">_kw</span><span class="p">,</span>  <span class="c1"># reserved to deprecate hydra_partial</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Type</span><span class="p">[</span><span class="n">_T</span><span class="p">]],</span> <span class="n">Type</span><span class="p">[</span><span class="n">_T</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;A decorator that uses `builds` to create a dataclass with the appropriate</span>
<span class="sd">    hydra-specific fields for specifying a structured config [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target : Union[Instantiable, Callable]</span>
<span class="sd">        The object to be instantiated/called.</span>

<span class="sd">    *pos_args : Any</span>
<span class="sd">        Positional arguments passed to ``target``.</span>

<span class="sd">        Arguments specified positionally are not included in the dataclass&#39; signature and</span>
<span class="sd">        are stored as a tuple bound to in the ``_args_`` field.</span>

<span class="sd">    zen_partial : Optional[bool] (default=False)</span>
<span class="sd">        If True, then hydra-instantiation produces ``functools.partial(target, **kwargs)``</span>

<span class="sd">    zen_wrappers : None | Callable | Builds | InterpStr | Sequence[None | Callable | Builds | InterpStr]</span>
<span class="sd">        One or more wrappers, which will wrap ``hydra_target`` prior to instantiation.</span>
<span class="sd">        E.g. specifying the wrappers ``[f1, f2, f3]`` will instantiate as::</span>

<span class="sd">            f3(f2(f1(hydra_target)))(*args, **kwargs)</span>

<span class="sd">        Wrappers can also be specified as interpolated strings [2]_ or targeted structured</span>
<span class="sd">        configs.</span>

<span class="sd">    zen_meta : Optional[Mapping[str, Any]]</span>
<span class="sd">        Specifies field-names and corresponding values that will be included in the</span>
<span class="sd">        resulting dataclass, but that will *not* be used to build ``hydra_target``</span>
<span class="sd">        via instantiation. These are called &quot;meta&quot; fields.</span>

<span class="sd">    populate_full_signature : bool, optional (default=False)</span>
<span class="sd">        If ``True``, then the resulting dataclass&#39;s signature and fields will be populated</span>
<span class="sd">        according to the signature of ``hydra_target``.</span>

<span class="sd">        Values specified in **kwargs_for_target take precedent over the corresponding</span>
<span class="sd">        default values from the signature.</span>

<span class="sd">        This option is not available for objects with inaccessible signatures, such as</span>
<span class="sd">        NumPy&#39;s various ufuncs.</span>

<span class="sd">    hydra_recursive : bool, optional (default=True)</span>
<span class="sd">        If True, then upon hydra will recursively instantiate all other</span>
<span class="sd">        hydra-config objects nested within this dataclass [3]_.</span>

<span class="sd">        If ``None``, the ``_recursive_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    hydra_convert : Optional[Literal[&quot;none&quot;, &quot;partial&quot;, &quot;all&quot;]] (default=&quot;none&quot;)</span>
<span class="sd">        Determines how hydra handles the non-primitive objects passed to `target` [4]_.</span>

<span class="sd">        - ``&quot;none&quot;``: Passed objects are DictConfig and ListConfig, default</span>
<span class="sd">        - ``&quot;partial&quot;``: Passed objects are converted to dict and list, with</span>
<span class="sd">          the exception of Structured Configs (and their fields).</span>
<span class="sd">        - ``&quot;all&quot;``: Passed objects are dicts, lists and primitives without</span>
<span class="sd">          a trace of OmegaConf containers</span>

<span class="sd">        If ``None``, the ``_convert_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    frozen : bool, optional (default=False)</span>
<span class="sd">        If `True`, the resulting dataclass will create frozen (i.e. immutable) instances.</span>
<span class="sd">        I.e. setting/deleting an attribute of an instance will raise `FrozenInstanceError`</span>
<span class="sd">        at runtime.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    builds : Create a targeted structured config designed to &quot;build&quot; a particular object.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://hydra.cc/docs/next/tutorials/structured_config/intro/</span>
<span class="sd">    .. [2] https://omegaconf.readthedocs.io/en/2.1_branch/usage.html#variable-interpolation</span>
<span class="sd">    .. [3] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#recursive-instantiation</span>
<span class="sd">    .. [4] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#parameter-conversion-strategies</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A simple usage of `hydrated_dataclass`. Here, we specify a structured config</span>

<span class="sd">    &gt;&gt;&gt; from hydra_zen import hydrated_dataclass, instantiate</span>
<span class="sd">    &gt;&gt;&gt; @hydrated_dataclass(target=dict)</span>
<span class="sd">    ... class DictConf:</span>
<span class="sd">    ...     x: int = 2</span>
<span class="sd">    ...     y: str = &#39;hello&#39;</span>

<span class="sd">    &gt;&gt;&gt; instantiate(DictConf(x=10))  # override default `x`</span>
<span class="sd">    {&#39;x&#39;: 10, &#39;y&#39;: &#39;hello&#39;}</span>

<span class="sd">    We can also design a configuration that only partially instantiates our target.</span>

<span class="sd">    &gt;&gt;&gt; def power(x: float, exponent: float) -&gt; float: return x ** exponent</span>
<span class="sd">    &gt;&gt;&gt; @hydrated_dataclass(target=power, zen_partial=True)</span>
<span class="sd">    ... class PowerConf:</span>
<span class="sd">    ...     exponent : float = 2.0</span>

<span class="sd">    &gt;&gt;&gt; partiald_power = instantiate(PowerConf)</span>
<span class="sd">    &gt;&gt;&gt; partiald_power(10.0)</span>
<span class="sd">    100.0</span>

<span class="sd">    Inheritance can be used to compose configurations</span>

<span class="sd">    &gt;&gt;&gt; from dataclasses import dataclass</span>
<span class="sd">    &gt;&gt;&gt; from torch.optim import AdamW</span>
<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class AdamBaseConfig:</span>
<span class="sd">    ...     lr: float = 0.001</span>
<span class="sd">    ...     eps: float = 1e-8</span>

<span class="sd">    &gt;&gt;&gt; @hydrated_dataclass(target=AdamW, zen_partial=True)</span>
<span class="sd">    ... class AdamWConfig(AdamBaseConfig):</span>
<span class="sd">    ...     weight_decay : float = 0.01</span>
<span class="sd">    &gt;&gt;&gt; instantiate(AdamWConfig)</span>
<span class="sd">    functools.partial(&lt;class &#39;torch.optim.adamw.AdamW&#39;&gt;, lr=0.001, eps=1e-08, weight_decay=0.01)</span>

<span class="sd">    Because this decorator uses `hyda_utils.builds` under the hood, common mistakes like misspelled</span>
<span class="sd">    parameters will be caught upon constructing the structured config.</span>

<span class="sd">    &gt;&gt;&gt; @hydrated_dataclass(target=AdamW, zen_partial=True)</span>
<span class="sd">    ... class AdamWConfig(AdamBaseConfig):</span>
<span class="sd">    ...     wieght_decay : float = 0.01  # i before e, right!?</span>
<span class="sd">    TypeError: Building: AdamW ..</span>
<span class="sd">    The following unexpected keyword argument(s) for torch.optim.adamw.AdamW was specified via inheritance</span>
<span class="sd">    from a base class: wieght_decay</span>

<span class="sd">    For more detailed examples, refer to `builds`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;hydra_partial&quot;</span> <span class="ow">in</span> <span class="n">_kw</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zen_partial</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Both `hydra_partial` and `zen_partial` are specified. &quot;</span>
                <span class="s2">&quot;Specifying `hydra_partial` is deprecated, use `zen_partial` &quot;</span>
                <span class="s2">&quot;instead.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># builds(..., hydra_partial=...) is deprecated</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="n">HydraZenDeprecationWarning</span><span class="p">(</span>
                <span class="s2">&quot;The argument `hydra_partial` is deprecated as of 2021-10-10.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Change `builds(..., hydra_partial=&lt;..&gt;)` to `builds(..., zen_partial=&lt;..&gt;)`.&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">This will be an error in hydra-zen 1.0.0, or by 2022-01-10 — whichever &quot;</span>
                <span class="s2">&quot;comes first.</span><span class="se">\n\n</span><span class="s2">Note: This deprecation does not impact yaml configs &quot;</span>
                <span class="s2">&quot;produced by `builds`.&quot;</span>
            <span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">zen_partial</span> <span class="o">=</span> <span class="n">_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;hydra_partial&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_kw</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;hydrated_dataclass got an unexpected argument: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_kw</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">decorated_obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decorated_obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Class instances are not supported by `hydrated_dataclass`.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># TODO: We should mutate `decorated_obj` directly like @dataclass does.</span>
        <span class="c1">#       Presently, we create an intermediate dataclass that we inherit</span>
        <span class="c1">#       from, which gets the job done for the most part but there are</span>
        <span class="c1">#       practical differences. E.g. you cannot delete an attribute that</span>
        <span class="c1">#       was declared in the definition of `decorated_obj`.</span>
        <span class="n">decorated_obj</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">decorated_obj</span><span class="p">)</span>
        <span class="n">decorated_obj</span> <span class="o">=</span> <span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">)(</span><span class="n">decorated_obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">builds</span><span class="p">(</span>
            <span class="n">target</span><span class="p">,</span>
            <span class="o">*</span><span class="n">pos_args</span><span class="p">,</span>
            <span class="n">populate_full_signature</span><span class="o">=</span><span class="n">populate_full_signature</span><span class="p">,</span>
            <span class="n">hydra_recursive</span><span class="o">=</span><span class="n">hydra_recursive</span><span class="p">,</span>
            <span class="n">hydra_convert</span><span class="o">=</span><span class="n">hydra_convert</span><span class="p">,</span>
            <span class="n">zen_wrappers</span><span class="o">=</span><span class="n">zen_wrappers</span><span class="p">,</span>
            <span class="n">zen_partial</span><span class="o">=</span><span class="n">zen_partial</span><span class="p">,</span>
            <span class="n">zen_meta</span><span class="o">=</span><span class="n">zen_meta</span><span class="p">,</span>
            <span class="n">builds_bases</span><span class="o">=</span><span class="p">(</span><span class="n">decorated_obj</span><span class="p">,),</span>
            <span class="n">dataclass_name</span><span class="o">=</span><span class="n">decorated_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>


<div class="viewcode-block" id="just"><a class="viewcode-back" href="../../../generated/hydra_zen.just.html#hydra_zen.just">[docs]</a><span class="k">def</span> <span class="nf">just</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Importable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Just</span><span class="p">[</span><span class="n">Importable</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Produces a structured config that, when instantiated by Hydra, &#39;just&#39;</span>
<span class="sd">    returns the target (uninstantiated).</span>

<span class="sd">    This is convenient for specifying a particular, un-instantiated object as part of your</span>
<span class="sd">    configuration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : Importable</span>
<span class="sd">        The object that will be instantiated from this config.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Type[Just[Importable]]</span>
<span class="sd">        The dataclass object that is designed as a structured config.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The configs produced by `just` introduce an explicit dependency on hydra-zen. I.e.</span>
<span class="sd">    hydra-zen must be installed in order to instantiate the config.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from hydra_zen import just, instantiate, to_yaml</span>
<span class="sd">    &gt;&gt;&gt; just_range = just(range)</span>
<span class="sd">    &gt;&gt;&gt; range is instantiate(just_range)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; just_range._target_</span>
<span class="sd">    &#39;hydra_zen.funcs.get_obj&#39;</span>
<span class="sd">    &gt;&gt;&gt; just_range.path</span>
<span class="sd">    &#39;builtins.range&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">obj_path</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`just(</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">)`: `obj` is not importable; it is missing the attributes `__module__` and/or `__qualname__`&quot;</span>
        <span class="p">)</span>

    <span class="n">out_class</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span>
        <span class="p">(</span><span class="s2">&quot;Just_&quot;</span> <span class="o">+</span> <span class="n">_utils</span><span class="o">.</span><span class="n">safe_name</span><span class="p">(</span><span class="n">obj</span><span class="p">)),</span>
        <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">_TARGET_FIELD_NAME</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">get_obj</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="s2">&quot;path&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span>
                    <span class="n">default</span><span class="o">=</span><span class="n">obj_path</span><span class="p">,</span>
                    <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">),</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="n">out_class</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;A structured config designed to return </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> when it is instantiated by hydra&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Type</span><span class="p">[</span><span class="n">Just</span><span class="p">[</span><span class="n">Importable</span><span class="p">]],</span> <span class="n">out_class</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">create_just_if_needed</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">_T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">_T</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">Just</span><span class="p">]]:</span>
    <span class="c1"># Hydra can serialize dataclasses directly, thus we</span>
    <span class="c1"># don&#39;t want to wrap these in `just`</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dataclass</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_builtin_function_or_method_type</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">ufunc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">))</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">just</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">sanitized_default_value</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Field</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">KNOWN_MUTABLE_TYPES</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Field</span><span class="p">,</span> <span class="n">mutable_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="n">resolved_value</span> <span class="o">=</span> <span class="n">create_just_if_needed</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">resolved_value</span>
        <span class="k">else</span> <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">resolved_value</span><span class="p">)</span>
    <span class="p">)</span>


<span class="c1"># overloads when `zen_partial=False`</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">builds</span><span class="p">(</span>
    <span class="n">hydra_target</span><span class="p">:</span> <span class="n">Importable</span><span class="p">,</span>
    <span class="o">*</span><span class="n">pos_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">zen_partial</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">zen_wrappers</span><span class="p">:</span> <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="n">zen_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">populate_full_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dataclass_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">builds_bases</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs_for_target</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">Builds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<span class="c1"># overloads when `zen_partial=True`</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">builds</span><span class="p">(</span>
    <span class="n">hydra_target</span><span class="p">:</span> <span class="n">Importable</span><span class="p">,</span>
    <span class="o">*</span><span class="n">pos_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">zen_partial</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
    <span class="n">zen_wrappers</span><span class="p">:</span> <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="n">zen_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">populate_full_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dataclass_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">builds_bases</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs_for_target</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">PartialBuilds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<span class="c1"># overloads when `zen_partial: bool`</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">builds</span><span class="p">(</span>
    <span class="n">hydra_target</span><span class="p">:</span> <span class="n">Importable</span><span class="p">,</span>
    <span class="o">*</span><span class="n">pos_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">zen_partial</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">zen_wrappers</span><span class="p">:</span> <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="n">zen_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">populate_full_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dataclass_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">builds_bases</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs_for_target</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Type</span><span class="p">[</span><span class="n">Builds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]],</span> <span class="n">Type</span><span class="p">[</span><span class="n">PartialBuilds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]]</span>
<span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<div class="viewcode-block" id="builds"><a class="viewcode-back" href="../../../generated/hydra_zen.builds.html#hydra_zen.builds">[docs]</a><span class="nd">@_hydra_partial_deprecation</span>
<span class="nd">@_target_as_kwarg_deprecation</span>
<span class="k">def</span> <span class="nf">builds</span><span class="p">(</span>
    <span class="o">*</span><span class="n">pos_args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">zen_partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">zen_wrappers</span><span class="p">:</span> <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="n">zen_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">populate_full_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">builds_bases</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">dataclass_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs_for_target</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Builds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]],</span> <span class="n">Type</span><span class="p">[</span><span class="n">PartialBuilds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;builds(hydra_target, /, *pos_args, zen_partial=False, zen_meta=None, hydra_recursive=None, populate_full_signature=False, hydra_convert=None, frozen=False, dataclass_name=None, builds_bases=(), **kwargs_for_target)</span>

<span class="sd">    Returns a dataclass object that configures ``&lt;hydra_target&gt;`` with user-specified and auto-populated parameter</span>
<span class="sd">    values.</span>

<span class="sd">    The resulting dataclass is specifically a structured config [1]_ that enables Hydra to initialize/call</span>
<span class="sd">    `target` either fully or partially. See Notes for additional features and explanation of implementation details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hydra_target : T (Callable)</span>
<span class="sd">        The object to be configured. This is a required, positional-only argument.</span>

<span class="sd">    *pos_args : Any</span>
<span class="sd">        Positional arguments passed to ``hydra_target``.</span>

<span class="sd">        Arguments specified positionally are not included in the dataclass&#39; signature and</span>
<span class="sd">        are stored as a tuple bound to in the ``_args_`` field.</span>

<span class="sd">    **kwargs_for_target : Any</span>
<span class="sd">        The keyword arguments passed to ``hydra_target(...)``.</span>

<span class="sd">        The arguments specified here solely determine the fields and init-parameters of the</span>
<span class="sd">        resulting dataclass, unless ``populate_full_signature=True`` is specified (see below).</span>

<span class="sd">        Named parameters of the forms ``hydra_xx``, ``zen_xx``, and ``_zen_xx`` are reserved</span>
<span class="sd">        to ensure future-compatibility, and cannot be specified by the user.</span>

<span class="sd">    zen_partial : bool, optional (default=False)</span>
<span class="sd">        If True, then the resulting config will instantiate as</span>
<span class="sd">        ``functools.partial(hydra_target, *pos_args, **kwargs_for_target)`` rather than</span>
<span class="sd">        ``hydra_target(*pos_args, **kwargs_for_target)``.</span>

<span class="sd">        Thus this enables the partial-configuration of objects.</span>

<span class="sd">        Specifying ``zen_partial=True`` and ``populate_full_signature=True`` together will</span>
<span class="sd">        populate the dataclass&#39; signature only with parameters that are specified by the</span>
<span class="sd">        user or that have default values specified in the target&#39;s signature. I.e. it is</span>
<span class="sd">        presumed that un-specified parameters are to be excluded from the partial configuration.</span>

<span class="sd">    zen_wrappers : None | Callable | Builds | InterpStr | Sequence[None | Callable | Builds | InterpStr]</span>
<span class="sd">        One or more wrappers, which will wrap ``hydra_target`` prior to instantiation.</span>
<span class="sd">        E.g. specifying the wrappers ``[f1, f2, f3]`` will instantiate as::</span>

<span class="sd">            f3(f2(f1(hydra_target)))(*args, **kwargs)</span>

<span class="sd">        Wrappers can also be specified as interpolated strings [2]_ or targeted structured</span>
<span class="sd">        configs.</span>

<span class="sd">    zen_meta : Optional[Mapping[str, Any]]</span>
<span class="sd">        Specifies field-names and corresponding values that will be included in the</span>
<span class="sd">        resulting dataclass, but that will *not* be used to build ``hydra_target``</span>
<span class="sd">        via instantiation. These are called &quot;meta&quot; fields.</span>

<span class="sd">    populate_full_signature : bool, optional (default=False)</span>
<span class="sd">        If ``True``, then the resulting dataclass&#39;s signature and fields will be populated</span>
<span class="sd">        according to the signature of ``hydra_target``.</span>

<span class="sd">        Values specified in **kwargs_for_target take precedent over the corresponding</span>
<span class="sd">        default values from the signature.</span>

<span class="sd">        This option is not available for objects with inaccessible signatures, such as</span>
<span class="sd">        NumPy&#39;s various ufuncs.</span>

<span class="sd">    hydra_recursive : Optional[bool], optional (default=True)</span>
<span class="sd">        If ``True``, then Hydra will recursively instantiate all other</span>
<span class="sd">        hydra-config objects nested within this dataclass [3]_.</span>

<span class="sd">        If ``None``, the ``_recursive_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    hydra_convert : Optional[Literal[&quot;none&quot;, &quot;partial&quot;, &quot;all&quot;]], optional (default=&quot;none&quot;)</span>
<span class="sd">        Determines how Hydra handles the non-primitive objects passed to `target` [4]_.</span>

<span class="sd">        - ``&quot;none&quot;``: Passed objects are DictConfig and ListConfig, default</span>
<span class="sd">        - ``&quot;partial&quot;``: Passed objects are converted to dict and list, with</span>
<span class="sd">          the exception of Structured Configs (and their fields).</span>
<span class="sd">        - ``&quot;all&quot;``: Passed objects are dicts, lists and primitives without</span>
<span class="sd">          a trace of OmegaConf containers</span>

<span class="sd">        If ``None``, the ``_convert_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    frozen : bool, optional (default=False)</span>
<span class="sd">        If ``True``, the resulting dataclass will create frozen (i.e. immutable) instances.</span>
<span class="sd">        I.e. setting/deleting an attribute of an instance will raise ``FrozenInstanceError``</span>
<span class="sd">        at runtime.</span>

<span class="sd">    builds_bases : Tuple[DataClass, ...]</span>
<span class="sd">        Specifies a tuple of parent classes that the resulting dataclass inherits from.</span>
<span class="sd">        A ``PartialBuilds`` class (resulting from ``zen_partial=True``) cannot be a parent</span>
<span class="sd">        of a ``Builds`` class (i.e. where `zen_partial=False` was specified).</span>

<span class="sd">    dataclass_name : Optional[str]</span>
<span class="sd">        If specified, determines the name of the returned class object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Config : Type[Builds[Type[T]]] |  Type[PartialBuilds[Type[T]]]</span>
<span class="sd">        A structured config that builds ``hydra_target``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Using any of the `zen_xx` features will result in a config that depends</span>
<span class="sd">    explicitly on hydra-zen. (i.e. hydra-zen must be installed in order to</span>
<span class="sd">    instantiate the resulting config, including its yaml version).</span>

<span class="sd">    Type annotations are inferred from the target&#39;s signature and are only</span>
<span class="sd">    retained if they are compatible with hydra&#39;s limited set of supported</span>
<span class="sd">    annotations; otherwise `Any` is specified.</span>

<span class="sd">    `builds` provides runtime validation of user-specified named arguments against</span>
<span class="sd">    the target&#39;s signature. This helps to ensure that typos in field names</span>
<span class="sd">    fail early and explicitly.</span>

<span class="sd">    Mutable values are automatically transformed to use a default factory [5]_</span>
<span class="sd">    prior to setting them on the dataclass.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://hydra.cc/docs/next/tutorials/structured_config/intro/</span>
<span class="sd">    .. [2] https://omegaconf.readthedocs.io/en/2.1_branch/usage.html#variable-interpolation</span>
<span class="sd">    .. [3] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#recursive-instantiation</span>
<span class="sd">    .. [4] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#parameter-conversion-strategies</span>
<span class="sd">    .. [5] https://docs.python.org/3/library/dataclasses.html#mutable-default-values</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    instantiate: Instantiates a configuration created by `builds`.</span>
<span class="sd">    make_custom_builds_fn: Returns the `builds` function, but with customized default values.</span>
<span class="sd">    make_config: Creates a config with customized field names, default values, and annotations.</span>
<span class="sd">    get_target: Returns the target-object from a targeted structured config.</span>
<span class="sd">    just: Produces a config that, when instantiated by Hydra, &quot;just&quot; returns the uninstantiated target.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic Usage:</span>

<span class="sd">    &gt;&gt;&gt; from hydra_zen import builds, instantiate</span>
<span class="sd">    &gt;&gt;&gt; Conf = builds(dict, a=1, b=&#39;x&#39;)  # makes a dataclass that will &quot;build&quot; a dictionary with the specified fields</span>
<span class="sd">    &gt;&gt;&gt; Conf  # signature: c(a: Any = 1, b: Any = &#39;x&#39;)</span>
<span class="sd">    types.Builds_dict</span>
<span class="sd">    &gt;&gt;&gt; instantiate(Conf)  # using Hydra to &quot;instantiate&quot; this build</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: &#39;x&#39;}</span>
<span class="sd">    &gt;&gt;&gt; instantiate(Conf(a=10, b=&quot;hi&quot;))  # overriding configuration values</span>
<span class="sd">    {&#39;a&#39;: 10, &#39;b&#39;: &#39;hi&#39;}</span>

<span class="sd">    &gt;&gt;&gt; Conf = builds(len, [1, 2, 3])  # specifying positional arguments</span>
<span class="sd">    &gt;&gt;&gt; instantiate(Conf)</span>
<span class="sd">    3</span>

<span class="sd">    Using `builds` to partially-configure a target</span>

<span class="sd">    &gt;&gt;&gt; def a_two_tuple(x: int, y: float): return x, y</span>
<span class="sd">    &gt;&gt;&gt; PartialConf = builds(a_two_tuple, x=1, zen_partial=True)  # configures only `x`</span>
<span class="sd">    &gt;&gt;&gt; partial_func = instantiate(PartialConf)</span>
<span class="sd">    &gt;&gt;&gt; partial_func</span>
<span class="sd">    functools.partial(&lt;function a_two_tuple at 0x00000220A7820EE0&gt;, x=1)</span>
<span class="sd">    &gt;&gt;&gt; partial_func(y=22.0)  # y can be provided after configuration &amp; instantiation</span>
<span class="sd">    (1, 22.0)</span>

<span class="sd">    Auto-populating parameters:</span>

<span class="sd">    &gt;&gt;&gt; Conf = builds(a_two_tuple, populate_full_signature=True)</span>
<span class="sd">    &gt;&gt;&gt; # signature: `Builds_a_two_tuple(x: int, y: float)`</span>
<span class="sd">    &gt;&gt;&gt; instantiate(Conf(x=1, y=10.0))</span>
<span class="sd">    (1, 10.0)</span>

<span class="sd">    Inheritance:</span>

<span class="sd">    &gt;&gt;&gt; ParentConf = builds(dict, a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; ChildConf = builds(dict, b=-2, c=-3, builds_bases=(ParentConf,))</span>
<span class="sd">    &gt;&gt;&gt; instantiate(ChildConf)</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: -2, &#39;c&#39;: -3}</span>
<span class="sd">    &gt;&gt;&gt; issubclass(ChildConf, ParentConf)</span>
<span class="sd">    True</span>

<span class="sd">    Leveraging meta-fields for portable, relative interpolation:</span>

<span class="sd">    &gt;&gt;&gt; Conf = builds(dict, a=&quot;${.s}&quot;, b=&quot;${.s}&quot;, zen_meta=dict(s=-10))</span>
<span class="sd">    &gt;&gt;&gt; instantiate(Conf)</span>
<span class="sd">    {&#39;a&#39;: -10, &#39;b&#39;: -10}</span>
<span class="sd">    &gt;&gt;&gt; instantiate(Conf, s=2)</span>
<span class="sd">    {&#39;a&#39;: 2, &#39;b&#39;: 2}</span>

<span class="sd">    Leveraging zen-wrappers to inject unit-conversion capabilities. Let&#39;s take</span>
<span class="sd">    a function that converts Farenheit to Celcius, and wrap it so that it converts</span>
<span class="sd">    to Kelvin instead.</span>

<span class="sd">    &gt;&gt;&gt; def faren_to_celsius(temp_f):</span>
<span class="sd">    ...     return ((temp_f - 32) * 5) / 9</span>

<span class="sd">    &gt;&gt;&gt; def change_celcius_to_kelvin(celc_func):</span>
<span class="sd">    ...     def wraps(*args, **kwargs):</span>
<span class="sd">    ...         return 273.15 + celc_func(*args, **kwargs)</span>
<span class="sd">    ...     return wraps</span>

<span class="sd">    &gt;&gt;&gt; AsCelcius = builds(faren_to_celsius)</span>
<span class="sd">    &gt;&gt;&gt; AsKelvin = builds(faren_to_celsius, zen_wrappers=change_celcius_to_kelvin)</span>
<span class="sd">    &gt;&gt;&gt; instantiate(AsCelcius, temp_f=32)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; instantiate(AsKelvin, temp_f=32)</span>
<span class="sd">    273.15</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pos_args</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwargs_for_target</span><span class="p">:</span>
        <span class="c1"># `builds()`</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;builds() missing 1 required positional argument: &#39;hydra_target&#39;&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">pos_args</span><span class="p">:</span>
        <span class="c1"># `builds(hydra_target=int)`</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;builds() missing 1 required positional-only argument: &#39;hydra_target&#39;&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Change `builds(hydra_target=&lt;target&gt;, ...)` to `builds(&lt;target&gt;, ...)`&quot;</span>
        <span class="p">)</span>

    <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">_pos_args</span> <span class="o">=</span> <span class="n">pos_args</span>

    <span class="k">del</span> <span class="n">pos_args</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;In `builds(&lt;target&gt;, ...), `&lt;target&gt;` must be callable/instantiable&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">populate_full_signature</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`populate_full_signature` must be a boolean type, got: </span><span class="si">{</span><span class="n">populate_full_signature</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">hydra_recursive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hydra_recursive</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`hydra_recursive` must be a boolean type, got </span><span class="si">{</span><span class="n">hydra_recursive</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zen_partial</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`zen_partial` must be a boolean type, got: </span><span class="si">{</span><span class="n">zen_partial</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hydra_convert</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hydra_convert</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`hydra_convert` must be &#39;none&#39;, &#39;partial&#39;, or &#39;all&#39;, got: </span><span class="si">{</span><span class="n">hydra_convert</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frozen</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;frozen must be a bool, got: </span><span class="si">{</span><span class="n">frozen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dataclass_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataclass_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`dataclass_name` must be a string or None, got: </span><span class="si">{</span><span class="n">dataclass_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_b</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span> <span class="k">for</span> <span class="n">_b</span> <span class="ow">in</span> <span class="n">builds_bases</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All `build_bases` must be a tuple of dataclass types&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zen_meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zen_meta</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zen_meta</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`zen_meta` must be a mapping (e.g. a dictionary), got: </span><span class="si">{</span><span class="n">zen_meta</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">zen_meta</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`zen_meta` must be a mapping whose keys are strings, got key(s):&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_key</span><span class="p">)</span> <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">zen_meta</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">zen_wrappers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zen_wrappers</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zen_wrappers</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">zen_wrappers</span> <span class="o">=</span> <span class="p">(</span><span class="n">zen_wrappers</span><span class="p">,)</span>

        <span class="n">validated_wrappers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Builds</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">zen_wrappers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrapper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># We are intentionally keeping each condition branched</span>
            <span class="c1"># so that test-coverage will be checked for each one</span>
            <span class="k">if</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">wrapper</span><span class="p">):</span>
                <span class="c1"># If Hydra&#39;s locate function starts supporting importing literals</span>
                <span class="c1"># – or if we decide to ship our own locate function –</span>
                <span class="c1"># then we should get the target of `wrapper` and make sure it is callable</span>
                <span class="k">if</span> <span class="n">is_just</span><span class="p">(</span><span class="n">wrapper</span><span class="p">):</span>
                    <span class="c1"># `zen_wrappers` handles importing string; we can</span>
                    <span class="c1"># elimintate the indirection of Just and &quot;flatten&quot; this</span>
                    <span class="c1"># config</span>
                    <span class="n">validated_wrappers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">_JUST_FIELD_NAME</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">hydra_recursive</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;A structured config was supplied for `zen_wrappers`. Its parent config has &quot;</span>
                            <span class="s2">&quot;`hydra_recursive=False`.</span><span class="se">\n</span><span class="s2"> If this value is not toggled to `True`, the config&#39;s &quot;</span>
                            <span class="s2">&quot;instantiation will result in an error&quot;</span>
                        <span class="p">)</span>
                    <span class="n">validated_wrappers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">wrapper</span><span class="p">):</span>
                <span class="n">validated_wrappers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">wrapper</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Assumed that wrapper is either a valid omegaconf-style interpolation string</span>
                <span class="c1"># or a &quot;valid&quot; path for importing an object. The latter seems hopeless for validating:</span>
                <span class="c1"># https://stackoverflow.com/a/47538106/6592114</span>
                <span class="c1"># so we can&#39;t make any assurances here.</span>
                <span class="n">validated_wrappers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`zen_wrappers` requires a callable, targeted config, or a string, got: </span><span class="si">{</span><span class="n">wrapper</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">del</span> <span class="n">zen_wrappers</span>
        <span class="n">validated_wrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">validated_wrappers</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">validated_wrappers</span> <span class="o">=</span> <span class="p">()</span>

    <span class="c1"># Check for reserved names</span>
    <span class="k">for</span> <span class="n">_name</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">kwargs_for_target</span><span class="p">,</span> <span class="n">zen_meta</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_name</span> <span class="ow">in</span> <span class="n">_HYDRA_FIELD_NAMES</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The field-name specified via `builds(..., </span><span class="si">{</span><span class="n">_name</span><span class="si">}</span><span class="s2">=&lt;...&gt;)` is reserved by Hydra.&quot;</span>
            <span class="k">if</span> <span class="n">_name</span> <span class="o">!=</span> <span class="n">_TARGET_FIELD_NAME</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">err_msg</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; You can set this parameter via `builds(..., hydra_</span><span class="si">{</span><span class="n">_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">=&lt;...&gt;)`&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s2">&quot;hydra_&quot;</span><span class="p">,</span> <span class="s2">&quot;_zen_&quot;</span><span class="p">,</span> <span class="s2">&quot;zen_&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The field-name specified via `</span><span class="si">{</span><span class="n">_name</span><span class="si">}</span><span class="s2">=&lt;...&gt;` is reserved by hydra-zen.&quot;</span>
                <span class="s2">&quot; You can manually create a dataclass to utilize this name in a structured config.&quot;</span>
            <span class="p">)</span>

    <span class="n">target_field</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Field</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]]</span>

    <span class="k">if</span> <span class="n">zen_partial</span> <span class="ow">or</span> <span class="n">zen_meta</span> <span class="ow">or</span> <span class="n">validated_wrappers</span><span class="p">:</span>
        <span class="n">target_field</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">_TARGET_FIELD_NAME</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">zen_processing</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="n">_ZEN_TARGET_FIELD_NAME</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">zen_partial</span><span class="p">:</span>
            <span class="n">target_field</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">_PARTIAL_TARGET_FIELD_NAME</span><span class="p">,</span>
                    <span class="nb">bool</span><span class="p">,</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">zen_meta</span><span class="p">:</span>
            <span class="n">target_field</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">_META_FIELD_NAME</span><span class="p">,</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">sanitized_type</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]),</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">zen_meta</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">validated_wrappers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">zen_meta</span><span class="p">:</span>
                <span class="c1"># Check to see</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">check_suspicious_interpolations</span><span class="p">(</span>
                        <span class="n">validated_wrappers</span><span class="p">,</span> <span class="n">zen_meta</span><span class="o">=</span><span class="n">zen_meta</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">validated_wrappers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># we flatten the config to avoid unnecessary list</span>
                <span class="n">target_field</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">_ZEN_WRAPPERS_FIELD_NAME</span><span class="p">,</span>
                        <span class="n">_utils</span><span class="o">.</span><span class="n">sanitized_type</span><span class="p">(</span>
                            <span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Builds</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Builds</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
                        <span class="p">),</span>
                        <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">validated_wrappers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_field</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">_ZEN_WRAPPERS_FIELD_NAME</span><span class="p">,</span>
                        <span class="n">_utils</span><span class="o">.</span><span class="n">sanitized_type</span><span class="p">(</span>
                            <span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Builds</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Builds</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
                        <span class="p">),</span>
                        <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">validated_wrappers</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_field</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">_TARGET_FIELD_NAME</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="n">base_fields</span> <span class="o">=</span> <span class="n">target_field</span>

    <span class="k">if</span> <span class="n">hydra_recursive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">base_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_RECURSIVE_FIELD_NAME</span><span class="p">,</span>
                <span class="nb">bool</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">hydra_recursive</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">hydra_convert</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">base_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">_CONVERT_FIELD_NAME</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">hydra_convert</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">_pos_args</span><span class="p">:</span>
        <span class="n">base_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_POS_ARG_FIELD_NAME</span><span class="p">,</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span>
                    <span class="n">default</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">create_just_if_needed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_pos_args</span><span class="p">),</span>
                    <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">signature_params</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
        <span class="n">target_has_valid_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">populate_full_signature</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> does not have an inspectable signature. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`builds(</span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">safe_name</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">, populate_full_signature=True)` is not supported&quot;</span>
            <span class="p">)</span>
        <span class="n">signature_params</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># We will turn off signature validation for objects that didn&#39;t have</span>
        <span class="c1"># a valid signature. This will enable us to do things like `build(dict, a=1)`</span>
        <span class="n">target_has_valid_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># this properly resolves forward references, whereas the annotations</span>
    <span class="c1"># from signature do not</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s2">&quot;__init__&quot;</span><span class="p">):</span>
            <span class="c1"># target is class object...</span>
            <span class="c1"># calling `get_type_hints(target)` returns empty dict</span>
            <span class="n">type_hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">):</span>
        <span class="c1"># TypeError: Covers case for ufuncs, which do not have inspectable type hints</span>
        <span class="c1"># NameError: Covers case for unresolved forward reference</span>
        <span class="n">type_hints</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span>

    <span class="n">sig_by_kind</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span> <span class="p">[],</span>
        <span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">:</span> <span class="p">[],</span>
        <span class="n">_VAR_POSITIONAL</span><span class="p">:</span> <span class="p">[],</span>
        <span class="n">_KEYWORD_ONLY</span><span class="p">:</span> <span class="p">[],</span>
        <span class="n">_VAR_KEYWORD</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">signature_params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># these are the names of the only parameters in the signature of `target` that can</span>
    <span class="c1"># be referenced by name</span>
    <span class="n">nameable_params_in_sig</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">.</span><span class="n">name</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">],</span> <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_KEYWORD_ONLY</span><span class="p">])</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_pos_args</span> <span class="ow">and</span> <span class="n">builds_bases</span><span class="p">:</span>
        <span class="c1"># pos_args is potentially inherited</span>
        <span class="k">for</span> <span class="n">_base</span> <span class="ow">in</span> <span class="n">builds_bases</span><span class="p">:</span>
            <span class="n">_pos_args</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_base</span><span class="p">,</span> <span class="n">_POS_ARG_FIELD_NAME</span><span class="p">,</span> <span class="p">())</span>
            <span class="k">if</span> <span class="n">_pos_args</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="n">fields_set_by_bases</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">_field</span><span class="o">.</span><span class="n">name</span>
        <span class="k">for</span> <span class="n">_base</span> <span class="ow">in</span> <span class="n">builds_bases</span>
        <span class="k">for</span> <span class="n">_field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">(</span><span class="n">_base</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_field</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_HYDRA_FIELD_NAMES</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_field</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_zen_&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1"># Validate that user-specified arguments satisfy target&#39;s signature.</span>
    <span class="c1"># Should catch:</span>
    <span class="c1">#    - bad parameter names</span>
    <span class="c1">#    - too many parameters-by-position</span>
    <span class="c1">#    - multiple values specified for parameter (via positional and by-name)</span>
    <span class="c1">#</span>
    <span class="c1"># We don&#39;t raise on an under-specified signature because it is possible that the</span>
    <span class="c1"># resulting dataclass will simply be inherited from and extended.</span>
    <span class="c1"># The issues we catch here cannot be fixed downstream.</span>
    <span class="k">if</span> <span class="n">target_has_valid_signature</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_VAR_KEYWORD</span><span class="p">]:</span>
            <span class="c1"># check for unexpected kwargs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs_for_target</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nameable_params_in_sig</span><span class="p">:</span>
                <span class="n">_unexpected</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs_for_target</span><span class="p">)</span> <span class="o">-</span> <span class="n">nameable_params_in_sig</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;The following unexpected keyword argument(s) was specified for </span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;via `builds`: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_unexpected</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fields_set_by_bases</span> <span class="o">&lt;=</span> <span class="n">nameable_params_in_sig</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="n">fields_set_by_bases</span> <span class="o">-</span> <span class="n">nameable_params_in_sig</span>
            <span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">zen_meta</span><span class="p">):</span>
                <span class="c1"># field inherited by base is not present in sig</span>
                <span class="c1"># AND it is not excluded via `zen_meta`</span>
                <span class="n">_unexpected</span> <span class="o">=</span> <span class="n">fields_set_by_bases</span> <span class="o">-</span> <span class="n">nameable_params_in_sig</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;The following unexpected keyword argument(s) for </span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;was specified via inheritance from a base class: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_unexpected</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">_pos_args</span><span class="p">:</span>
            <span class="n">named_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs_for_target</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fields_set_by_bases</span><span class="p">)</span>

            <span class="c1"># indicates that number of parameters that could be specified by name,</span>
            <span class="c1"># but are specified by position</span>
            <span class="n">_num_nameable_args_by_position</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_pos_args</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_POSITIONAL_ONLY</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">named_args</span><span class="p">:</span>
                <span class="c1"># check for multiple values for arg, specified both via positional and kwarg</span>
                <span class="c1"># E.g.: def f(x, y): ...</span>
                <span class="c1"># f(1, 2, y=3)  # multiple values for `y`</span>
                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">][</span>
                    <span class="p">:</span><span class="n">_num_nameable_args_by_position</span>
                <span class="p">]:</span>
                    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">named_args</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Multiple values for argument </span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> were specified for &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2"> via `builds`&quot;</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sig_by_kind</span><span class="p">[</span>
                <span class="n">_VAR_POSITIONAL</span>
            <span class="p">]</span> <span class="ow">and</span> <span class="n">_num_nameable_args_by_position</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># Too many positional args specified.</span>
                <span class="c1"># E.g.: def f(x, y): ...</span>
                <span class="c1"># f(1, 2, 3)</span>
                <span class="n">_num_positional</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_POSITIONAL_ONLY</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_POSITIONAL_OR_KEYWORD</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">_num_with_default</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
                    <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">_POSITIONAL_OR_KEYWORD</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">signature_params</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">_permissible</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_num_positional</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">_num_with_default</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_num_positional</span> <span class="o">-</span> <span class="n">_num_with_default</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">_num_positional</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2"> takes </span><span class="si">{</span><span class="n">_permissible</span><span class="si">}</span><span class="s2"> positional args, but &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">_pos_args</span><span class="p">)</span><span class="si">}</span><span class="s2"> were specified via `builds`&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Create valid dataclass fields from the user-specified values</span>
    <span class="c1">#</span>
    <span class="c1"># user_specified_params: arg-name -&gt; (arg-name, arg-type, field-w-value)</span>
    <span class="c1">#  - arg-type: taken from the parameter&#39;s annotation in the target&#39;s signature</span>
    <span class="c1">#    and is resolved to one of the type-annotations supported by hydra if possible,</span>
    <span class="c1">#    otherwise, is Any</span>
    <span class="c1">#  - arg-value: mutable values are automatically specified using default-factory</span>
    <span class="n">user_specified_named_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">Field</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">_utils</span><span class="o">.</span><span class="n">sanitized_type</span><span class="p">(</span><span class="n">type_hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Any</span><span class="p">))</span>
            <span class="c1"># OmegaConf&#39;s type-checking occurs before instantiation occurs.</span>
            <span class="c1"># This means that, e.g., passing `Builds[int]` to a field `x: int`</span>
            <span class="c1"># will fail Hydra&#39;s type-checking upon instantiation, even though</span>
            <span class="c1"># the recursive instantiation will appropriately produce `int` for</span>
            <span class="c1"># that field. This will not be addressed by hydra/omegaconf:</span>
            <span class="c1">#    https://github.com/facebookresearch/hydra/issues/1759</span>
            <span class="c1"># Thus we will auto-broaden the annotation when we see that the user</span>
            <span class="c1"># has specified a `Builds` as a default value.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">hydra_recursive</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="n">Any</span><span class="p">,</span>
            <span class="n">sanitized_default_value</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs_for_target</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">zen_meta</span><span class="p">:</span>
        <span class="n">_meta_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">zen_meta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_meta_names</span> <span class="o">&amp;</span> <span class="n">nameable_params_in_sig</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`builds(..., zen_meta=&lt;...&gt;)`: `zen_meta` cannot not specify &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;names that exist in the target&#39;s signature: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_meta_names</span> <span class="o">&amp;</span> <span class="n">nameable_params_in_sig</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_meta_names</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">user_specified_named_params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`builds(..., zen_meta=&lt;...&gt;)`: `zen_meta` cannot not specify &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;names that are common with those specified in **kwargs_for_target: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_meta_names</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">user_specified_named_params</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># We don&#39;t check for collisions between `zen_meta` names and the</span>
        <span class="c1"># names of inherited fields. Thus `zen_meta` can effectively be used</span>
        <span class="c1"># to &quot;delete&quot; names from a config, via inheritance.</span>
        <span class="n">user_specified_named_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">sanitized_default_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">zen_meta</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">populate_full_signature</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Populate dataclass fields based on the target&#39;s signature.</span>
        <span class="c1">#</span>
        <span class="c1"># A user-specified parameter value (via `kwargs_for_target`) takes precedent over</span>
        <span class="c1"># the default-value from the signature</span>

        <span class="c1"># Fields with default values must come after those without defaults,</span>
        <span class="c1"># so we will collect these as we loop through the parameters and</span>
        <span class="c1"># add them to the fields at the end.</span>
        <span class="c1">#</span>
        <span class="c1"># Parameter ordering should only differ from the target&#39;s signature</span>
        <span class="c1"># if the user specified a value for a parameter that had no default</span>
        <span class="n">_fields_with_default_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Field_Entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># we need to keep track of what user-specified params we have set</span>
        <span class="n">_seen</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">signature_params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_pos_args</span><span class="p">):</span>
                <span class="c1"># Positional parameters are populated from &quot;left to right&quot; in the signature.</span>
                <span class="c1"># We have already done validation, so we know that positional params aren&#39;t redundant</span>
                <span class="c1"># with named params (including inherited params).</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nameable_params_in_sig</span><span class="p">:</span>
                <span class="c1"># parameter cannot be specified by name</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">user_specified_named_params</span><span class="p">:</span>
                <span class="c1"># user-specified parameter is preferred</span>
                <span class="n">_fields_with_default_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">user_specified_named_params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">_seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">fields_set_by_bases</span><span class="p">:</span>
                <span class="c1"># don&#39;t populate a parameter that can be derived from a base</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># any parameter whose default value is None is automatically</span>
                <span class="c1"># annotated with `Optional[...]`. This improves flexibility with</span>
                <span class="c1"># Hydra&#39;s type-validation</span>
                <span class="n">param_field</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">sanitized_type</span><span class="p">(</span>
                        <span class="n">type_hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Any</span><span class="p">),</span>
                        <span class="n">wrap_optional</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">zen_partial</span><span class="p">:</span>
                        <span class="c1"># No default value specified in signature or by the user.</span>
                        <span class="c1"># We don&#39;t include these fields if the user specified a partial build</span>
                        <span class="c1"># because we assume that they want to fill these in by using partial</span>
                        <span class="n">base_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_field</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">param_field</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sanitized_default_value</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">),)</span>
                    <span class="n">_fields_with_default_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_field</span><span class="p">)</span>

        <span class="n">base_fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_fields_with_default_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sig_by_kind</span><span class="p">[</span><span class="n">_VAR_KEYWORD</span><span class="p">]:</span>
            <span class="c1"># if the signature has **kwargs, then we need to add any user-specified</span>
            <span class="c1"># parameters that have not already been added</span>
            <span class="n">base_fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">entry</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">user_specified_named_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_seen</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base_fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">user_specified_named_params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">dataclass_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zen_partial</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">dataclass_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Builds_</span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">safe_name</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dataclass_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;PartialBuilds_</span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">safe_name</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span>
        <span class="n">dataclass_name</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">base_fields</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">builds_bases</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">zen_partial</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">_PARTIAL_TARGET_FIELD_NAME</span><span class="p">):</span>
        <span class="c1"># `out._partial_target_` has been inherited; this will lead to an error when</span>
        <span class="c1"># hydra-instantiation occurs, since it will be passed to target.</span>
        <span class="c1"># There is not an easy way to delete this, since it comes from a parent class</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="n">_utils</span><span class="o">.</span><span class="n">building_error_prefix</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;`builds(..., zen_partial=False, builds_bases=(...))` does not &quot;</span>
            <span class="s2">&quot;permit `builds_bases` where a partial target has been specified.&quot;</span>
        <span class="p">)</span>

    <span class="n">out</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;A structured config designed to </span><span class="si">{</span><span class="s1">&#39;partially &#39;</span> <span class="k">if</span> <span class="n">zen_partial</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">initialize/call &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">get_obj_path</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">` upon instantiation by hydra.&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">):</span>
        <span class="n">target_doc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">if</span> <span class="n">target_doc</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">The docstring for </span><span class="si">{</span><span class="n">_utils</span><span class="o">.</span><span class="n">safe_name</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2"> :</span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">target_doc</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Type</span><span class="p">[</span><span class="n">Builds</span><span class="p">[</span><span class="n">Importable</span><span class="p">]],</span> <span class="n">out</span><span class="p">)</span></div>


<span class="c1"># We need to check if things are Builds, Just, PartialBuilds to a higher</span>
<span class="c1"># fidelity than is provided by `isinstance(..., &lt;Protocol&gt;)`. I.e. we want to</span>
<span class="c1"># check that the desired attributes *and* that their values match those of the</span>
<span class="c1"># protocols. Failing to heed this would, for example, lead to any `Builds` that</span>
<span class="c1"># happens to have a `path` attribute to be treated as `Just` in `get_target`.</span>
<span class="c1">#</span>
<span class="c1"># The following functions perform these desired checks. Note that they do not</span>
<span class="c1"># require that the provided object be a dataclass; this enables compatibility</span>
<span class="c1"># with omegaconf containers.</span>
<span class="c1">#</span>
<span class="c1"># These are not part of the public API for now, but they may be in the future.</span>
<span class="k">def</span> <span class="nf">is_builds</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">Builds</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_TARGET_FIELD_NAME</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_just</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">Just</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_JUST_FIELD_NAME</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">_get_target</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="n">_get_target</span><span class="p">(</span><span class="n">Just</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">is</span> <span class="n">get_obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensures we conver this branch in tests</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_is_old_partial_builds</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="c1"># We don&#39;t care about coverage here.</span>
    <span class="c1"># This will only be used in `get_target` and we&#39;ll be sure to cover that branch</span>
    <span class="k">if</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_partial_target_&quot;</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">_get_target</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;hydra_zen.funcs.partial&quot;</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">is</span> <span class="n">partial</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_just</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;_partial_target_&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensures we conver this branch in tests</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">uses_zen_processing</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">Builds</span><span class="p">]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_ZEN_TARGET_FIELD_NAME</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="n">_get_target</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">attr</span> <span class="o">!=</span> <span class="n">_ZEN_PROCESSING_LOCATION</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">zen_processing</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">is_partial_builds</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">PartialBuilds</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">uses_zen_processing</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_PARTIAL_TARGET_FIELD_NAME</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>
    <span class="p">)</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PartialBuilds</span><span class="p">[</span><span class="n">_T</span><span class="p">],</span> <span class="n">Type</span><span class="p">[</span><span class="n">PartialBuilds</span><span class="p">[</span><span class="n">_T</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Just</span><span class="p">[</span><span class="n">_T</span><span class="p">],</span> <span class="n">Type</span><span class="p">[</span><span class="n">Just</span><span class="p">[</span><span class="n">_T</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Builds</span><span class="p">[</span><span class="n">_T</span><span class="p">],</span> <span class="n">Type</span><span class="p">[</span><span class="n">Builds</span><span class="p">[</span><span class="n">_T</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">HasTarget</span><span class="p">,</span> <span class="n">HasPartialTarget</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="o">...</span>


<div class="viewcode-block" id="get_target"><a class="viewcode-back" href="../../../generated/hydra_zen.get_target.html#hydra_zen.get_target">[docs]</a><span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">HasTarget</span><span class="p">,</span> <span class="n">HasPartialTarget</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the target-object from a targeted structured config.</span>

<span class="sd">    The target is imported and returned if the config&#39;s ``_target_``</span>
<span class="sd">    field is a string that indicates its location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : HasTarget | HasPartialTarget</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    target : Any</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from hydra_zen import builds, just, get_target, load_from_yaml</span>
<span class="sd">    &gt;&gt;&gt; get_target(builds(int))</span>
<span class="sd">    int</span>
<span class="sd">    &gt;&gt;&gt; get_target(just(str))</span>
<span class="sd">    str</span>

<span class="sd">    This works even if the ``_target_`` field specifies a string.</span>

<span class="sd">    &gt;&gt;&gt; from dataclasses import dataclass</span>
<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class A:</span>
<span class="sd">    ...     _target_: str = &quot;builtins.dict&quot;</span>
<span class="sd">    &gt;&gt;&gt; get_target(A)</span>
<span class="sd">    dict</span>

<span class="sd">    This function is useful for accessing a target&#39;s type from a config</span>
<span class="sd">    without having to instantiate the target. For example, suppose we want</span>
<span class="sd">    to access a type from a yaml-serialized config.</span>

<span class="sd">    &gt;&gt;&gt; ModelConfig = load_from_yaml(&quot;model.yaml&quot;)</span>
<span class="sd">    &gt;&gt;&gt; get_target(ModelConfig)</span>
<span class="sd">    CustomClassifier</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_is_old_partial_builds</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># obj._partial_target_ is `Just[obj]`</span>
        <span class="k">return</span> <span class="n">get_target</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;_partial_target_&quot;</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">uses_zen_processing</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">field_name</span> <span class="o">=</span> <span class="n">_ZEN_TARGET_FIELD_NAME</span>
    <span class="k">elif</span> <span class="n">is_just</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">field_name</span> <span class="o">=</span> <span class="n">_JUST_FIELD_NAME</span>
    <span class="k">elif</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">field_name</span> <span class="o">=</span> <span class="n">_TARGET_FIELD_NAME</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`obj` must specify a target; i.e. it must have an attribute named&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">_TARGET_FIELD_NAME</span><span class="si">}</span><span class="s2"> or named </span><span class="si">{</span><span class="n">_PARTIAL_TARGET_FIELD_NAME</span><span class="si">}</span><span class="s2"> that&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; points to a target-object or target-string&quot;</span>
        <span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">get_obj</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Hydra 1.1.0 permits objects-as-_target_ instead of strings</span>
        <span class="c1"># https://github.com/facebookresearch/hydra/issues/1017</span>
        <span class="k">pass</span>  <span class="c1"># makes sure we cover this branch in tests</span>

    <span class="k">return</span> <span class="n">target</span></div>


<span class="n">_builds_sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">builds</span><span class="p">)</span>
<span class="n">__BUILDS_DEFAULTS</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">_builds_sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">p</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="p">}</span>
<span class="k">del</span> <span class="n">_builds_sig</span>


<div class="viewcode-block" id="make_custom_builds_fn"><a class="viewcode-back" href="../../../generated/hydra_zen.make_custom_builds_fn.html#hydra_zen.make_custom_builds_fn">[docs]</a><span class="k">def</span> <span class="nf">make_custom_builds_fn</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">zen_partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">zen_wrappers</span><span class="p">:</span> <span class="n">ZenWrappers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="n">zen_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">populate_full_signature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">builds_bases</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="c1"># This is the easiest way to get static tooling to see the output</span>
    <span class="c1"># as `builds`.</span>
    <span class="n">__b</span><span class="p">:</span> <span class="n">_T2</span> <span class="o">=</span> <span class="n">builds</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_T2</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns the `builds` function, but with customized default values.</span>

<span class="sd">    E.g. ``make_custom_builds_fn(hydra_convert=&#39;all&#39;)`` will return a version</span>
<span class="sd">    of the `builds` function where the default value for ``hydra_convert``</span>
<span class="sd">    is ``&#39;all&#39;`` instead of ``None``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zen_partial : bool, optional (default=False)</span>
<span class="sd">        If True, then the resulting config will instantiate as</span>
<span class="sd">        ``functools.partial(hydra_target, *pos_args, **kwargs_for_target)`` rather than</span>
<span class="sd">        ``hydra_target(*pos_args, **kwargs_for_target)``.</span>

<span class="sd">        Thus this enables the partial-configuration of objects.</span>

<span class="sd">        Specifying ``zen_partial=True`` and ``populate_full_signature=True`` together will</span>
<span class="sd">        populate the dataclass&#39; signature only with parameters that are specified by the</span>
<span class="sd">        user or that have default values specified in the target&#39;s signature. I.e. it is</span>
<span class="sd">        presumed that un-specified parameters are to be excluded from the partial configuration.</span>

<span class="sd">    zen_wrappers : None | Callable | Builds | InterpStr | Sequence[None | Callable | Builds | InterpStr]</span>
<span class="sd">        One or more wrappers, which will wrap ``hydra_target`` prior to instantiation.</span>
<span class="sd">        E.g. specifying the wrappers ``[f1, f2, f3]`` will instantiate as::</span>

<span class="sd">            f3(f2(f1(hydra_target)))(*args, **kwargs)</span>

<span class="sd">        Wrappers can also be specified as interpolated strings [1]_ or targeted structured</span>
<span class="sd">        configs.</span>

<span class="sd">    zen_meta : Optional[Mapping[str, Any]]</span>
<span class="sd">        Specifies field-names and corresponding values that will be included in the</span>
<span class="sd">        resulting dataclass, but that will *not* be used to build ``hydra_target``</span>
<span class="sd">        via instantiation. These are called &quot;meta&quot; fields.</span>

<span class="sd">    populate_full_signature : bool, optional (default=False)</span>
<span class="sd">        If ``True``, then the resulting dataclass&#39;s signature and fields will be populated</span>
<span class="sd">        according to the signature of ``hydra_target``.</span>

<span class="sd">        Values specified in **kwargs_for_target take precedent over the corresponding</span>
<span class="sd">        default values from the signature.</span>

<span class="sd">        This option is not available for objects with inaccessible signatures, such as</span>
<span class="sd">        NumPy&#39;s various ufuncs.</span>

<span class="sd">    hydra_recursive : Optional[bool], optional (default=True)</span>
<span class="sd">        If ``True``, then Hydra will recursively instantiate all other</span>
<span class="sd">        hydra-config objects nested within this dataclass [2]_.</span>

<span class="sd">        If ``None``, the ``_recursive_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    hydra_convert : Optional[Literal[&quot;none&quot;, &quot;partial&quot;, &quot;all&quot;]], optional (default=&quot;none&quot;)</span>
<span class="sd">        Determines how hydra handles the non-primitive objects passed to ``hydra_target`` [3]_.</span>

<span class="sd">        - ``&quot;none&quot;``: Passed objects are DictConfig and ListConfig, default</span>
<span class="sd">        - ``&quot;partial&quot;``: Passed objects are converted to dict and list, with</span>
<span class="sd">          the exception of Structured Configs (and their fields).</span>
<span class="sd">        - ``&quot;all&quot;``: Passed objects are dicts, lists and primitives without</span>
<span class="sd">          a trace of OmegaConf containers</span>

<span class="sd">        If ``None``, the ``_convert_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    frozen : bool, optional (default=False)</span>
<span class="sd">        If ``True``, the resulting dataclass will create frozen (i.e. immutable) instances.</span>
<span class="sd">        I.e. setting/deleting an attribute of an instance will raise ``FrozenInstanceError``</span>
<span class="sd">        at runtime.</span>

<span class="sd">    builds_bases : Tuple[DataClass, ...]</span>
<span class="sd">        Specifies a tuple of parent classes that the resulting dataclass inherits from.</span>
<span class="sd">        A ``PartialBuilds`` class (resulting from ``zen_partial=True``) cannot be a parent</span>
<span class="sd">        of a ``Builds`` class (i.e. where `zen_partial=False` was specified).</span>

<span class="sd">    returns</span>
<span class="sd">    -------</span>
<span class="sd">    builds</span>
<span class="sd">        The function `builds`, but with customized default-values.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://omegaconf.readthedocs.io/en/2.1_branch/usage.html#variable-interpolation</span>
<span class="sd">    .. [2] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#recursive-instantiation</span>
<span class="sd">    .. [3] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#parameter-conversion-strategies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    builds : Create a targeted structured config designed to &quot;build&quot; a particular object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from hydra_zen import builds, make_custom_builds_fn, instantiate</span>

<span class="sd">    The following will create a `builds` function whose default-value</span>
<span class="sd">    for ``zen_partial`` has been set to ``True``.</span>

<span class="sd">    &gt;&gt;&gt; pbuilds = make_custom_builds_fn(zen_partial=True)</span>

<span class="sd">    I.e. using ``pbuilds(...)`` is equivalent to using</span>
<span class="sd">    ``builds(..., zen_partial=True)``.</span>

<span class="sd">    &gt;&gt;&gt; instantiate(pbuilds(int))  # calls `functools.partial(int)`</span>
<span class="sd">    functools.partial(&lt;class &#39;int&#39;&gt;)</span>
<span class="sd">    &gt;&gt;&gt; instantiate(builds(int, zen_partial=True))  # manually-overriding default</span>
<span class="sd">    functools.partial(&lt;class &#39;int&#39;&gt;)</span>

<span class="sd">    You can still specify ``zen_partial`` on a per-case basis with ``pbuilds``</span>

<span class="sd">    &gt;&gt;&gt; instantiate(pbuilds(int, zen_partial=False))  # calls `int()`</span>
<span class="sd">    0</span>

<span class="sd">    Suppose that we want to enable runtime type-checking - using beartype -</span>
<span class="sd">    whenever our configs are being instantiated; then the following settings</span>
<span class="sd">    for `builds` would be handy</span>

<span class="sd">    &gt;&gt;&gt; from hydra_zen.third_party.beartype import validates_with_beartype</span>
<span class="sd">    &gt;&gt;&gt; build_a_bear = make_custom_builds_fn(</span>
<span class="sd">    ...     populate_full_signature=True,</span>
<span class="sd">    ...     hydra_convert=&quot;all&quot;,</span>
<span class="sd">    ...     zen_wrappers=validates_with_beartype,</span>
<span class="sd">    ... )</span>

<span class="sd">    Now all configs produced via ``build_a_bear`` will include type-checking</span>
<span class="sd">    during instantiation.</span>

<span class="sd">    &gt;&gt;&gt; from typing_extensions import Literal</span>
<span class="sd">    &gt;&gt;&gt; def f(x: Literal[&quot;a&quot;, &quot;b&quot;]): return x</span>
<span class="sd">    &gt;&gt;&gt; conf = build_a_bear(f)</span>
<span class="sd">    &gt;&gt;&gt; instantiate(conf, x=&quot;a&quot;)</span>
<span class="sd">    &quot;a&quot;</span>
<span class="sd">    &gt;&gt;&gt; instantiate(conf, x=&quot;c&quot;)</span>
<span class="sd">    &lt;Validation error: &quot;c&quot; is not &quot;a&quot; or &quot;b&quot;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">__b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">builds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;make_custom_builds_fn() got an unexpected argument: &#39;__b&#39;&quot;</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">__b</span>

    <span class="n">excluded_fields</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dataclass_name&quot;</span><span class="p">}</span>
    <span class="n">LOCALS</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>

    <span class="c1"># Ensures that new defaults added to `builds` must be reflected</span>
    <span class="c1"># in the signature of `make_custom_builds_fn`.</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">__BUILDS_DEFAULTS</span><span class="p">)</span> <span class="o">-</span> <span class="n">excluded_fields</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">LOCALS</span><span class="p">)</span>

    <span class="n">_new_defaults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">LOCALS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">__BUILDS_DEFAULTS</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded_fields</span>
    <span class="p">}</span>

    <span class="c1"># let `builds` validate the new defaults!</span>
    <span class="n">builds</span><span class="p">(</span><span class="n">builds</span><span class="p">,</span> <span class="o">**</span><span class="n">_new_defaults</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">builds</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">merged_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">merged_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_new_defaults</span><span class="p">)</span>
        <span class="n">merged_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">builds</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">merged_kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">_T2</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">NOTHING</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`NOTHING` cannot be instantiated&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ZenField"><a class="viewcode-back" href="../../../generated/hydra_zen.ZenField.html#hydra_zen.ZenField">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ZenField</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ZenField(hint=Any, default=&lt;class &#39;NOTHING&#39;&gt;, name=&lt;class &#39;NOTHING&#39;&gt;)</span>

<span class="sd">    Specifies a field&#39;s name and/or type-annotation and/or default-value.</span>
<span class="sd">    Designed to specify fields in `make_config`.</span>

<span class="sd">    See the Examples section of the docstring for `make_config` for examples of using</span>
<span class="sd">    `ZenField`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hint : type, optional (default=Any)</span>
<span class="sd">    default : Any, optional</span>
<span class="sd">    name : str, optional</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``default`` will be returned as an instance of ``dataclasses.Field``.</span>
<span class="sd">    Mutable values (e.g. lists or dictionaries) passed to ``default`` will automatically</span>
<span class="sd">    be &quot;packaged&quot; in a default-factory function [1]_.</span>

<span class="sd">    A type passed to ``hint`` will automatically be &quot;broadened&quot; such that the resulting</span>
<span class="sd">    type is compatible with Hydra&#39;s set of supported type annotations [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://docs.python.org/3/library/dataclasses.html#default-factory-functions</span>
<span class="sd">    .. [2] https://hydra.cc/docs/next/tutorials/structured_config/intro/#structured-configs-supports</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    make_config: create a config with customized field names, default values, and annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hint</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">Any</span>
    <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">NOTHING</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="n">NOTHING</span><span class="p">]]</span> <span class="o">=</span> <span class="n">NOTHING</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`ZenField.name` expects a string, got: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hint</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">sanitized_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">sanitized_default_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_config"><a class="viewcode-back" href="../../../generated/hydra_zen.make_config.html#hydra_zen.make_config">[docs]</a><span class="k">def</span> <span class="nf">make_config</span><span class="p">(</span>
    <span class="o">*</span><span class="n">fields_as_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">],</span>
    <span class="n">hydra_recursive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hydra_convert</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;partial&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">config_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Config&quot;</span><span class="p">,</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">bases</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">DataClass</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="o">**</span><span class="n">fields_as_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">DataClass</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a structured config with user-defined fieldnames and, optionally,</span>
<span class="sd">    associated default values and/or type-annotations.</span>

<span class="sd">    Unlike `builds`, `make_config` is not used to configure a particular target</span>
<span class="sd">    object, rather, it can be used to create more general structured configs [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *fields_as_args : str | ZenField</span>
<span class="sd">        The names of the fields to be be included in the config. Or,</span>
<span class="sd">        the fields&#39; names and their default values and/or their type</span>
<span class="sd">        annotations, expressed via `ZenField` instances.</span>

<span class="sd">    **fields_as_kwargs : Any | ZenField</span>
<span class="sd">        Like ``fields_as_args``, but fieldname/default-value pairs are</span>
<span class="sd">        specified as keyword arguments. `ZenField` can also be used here</span>
<span class="sd">        to express a fields type-annotation and/or its default value.</span>

<span class="sd">        Named parameters of the forms ``hydra_xx``, ``zen_xx``, and ``_zen_xx`` are reserved</span>
<span class="sd">        to ensure future-compatibility, and cannot be specified by the user.</span>

<span class="sd">    hydra_recursive : Optional[bool], optional (default=True)</span>
<span class="sd">        If ``True``, then Hydra will recursively instantiate all other</span>
<span class="sd">        hydra-config objects nested within this dataclass [2]_.</span>

<span class="sd">        If ``None``, the ``_recursive_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    hydra_convert : Optional[Literal[&quot;none&quot;, &quot;partial&quot;, &quot;all&quot;]], optional (default=&quot;none&quot;)</span>
<span class="sd">        Determines how Hydra handles the non-primitive objects passed to configuations [3]_.</span>

<span class="sd">        - ``&quot;none&quot;``: Passed objects are DictConfig and ListConfig, default</span>
<span class="sd">        - ``&quot;partial&quot;``: Passed objects are converted to dict and list, with</span>
<span class="sd">            the exception of Structured Configs (and their fields).</span>
<span class="sd">        - ``&quot;all&quot;``: Passed objects are dicts, lists and primitives without</span>
<span class="sd">            a trace of OmegaConf containers</span>

<span class="sd">        If ``None``, the ``_convert_`` attribute is not set on the resulting dataclass.</span>

<span class="sd">    bases : Tuple[Type[DataClass], ...], optional (default=())</span>
<span class="sd">        Base classes that the resulting config class will inherit from.</span>

<span class="sd">    frozen : bool, optional (default=False)</span>
<span class="sd">        If ``True``, the resulting config class will produce &#39;frozen&#39; (i.e. immutable) instances.</span>
<span class="sd">        I.e. setting/deleting an attribute of an instance of the config will raise</span>
<span class="sd">        ``dataclasses.FrozenInstanceError`` at runtime.</span>

<span class="sd">    config_name : str, optional (default=&quot;Config&quot;)</span>
<span class="sd">        The class name of the resulting config class.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Config : Type[DataClass]</span>
<span class="sd">        The resulting config class; a dataclass that possess the user-specified fields.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Any field specified without a type-annotation is automatically annotated with ``typing.Any``.</span>
<span class="sd">    Hydra only supports a narrow subset of types [4]_; `make_config` will automatically &#39;broaden&#39;</span>
<span class="sd">    any user-specified annotations so that they are compatible with Hydra.</span>

<span class="sd">    `make_config` will automatically manipulate certain types of default values to ensure that</span>
<span class="sd">    they can be utilized in the resulting dataclass and by Hydra:</span>

<span class="sd">    - Mutable default values will automatically be packaged in a default factory function [5]_</span>
<span class="sd">    - A default value that is a class-object or function-object will automatically be wrapped by</span>
<span class="sd">    `just`, to ensure that the resulting config is serializable by Hydra.</span>

<span class="sd">    For finer-grain control over how type-annotations and default values are managed, consider using</span>
<span class="sd">    ``dataclasses.make_dataclass`` [6]_.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    builds : Create a targeted structured config designed to &quot;build&quot; a particular object.</span>
<span class="sd">    just : Create a config that &#39;just&#39; returns a class-object or function, without instantiating/calling it.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://hydra.cc/docs/next/tutorials/structured_config/intro/</span>
<span class="sd">    .. [2] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#recursive-instantiation</span>
<span class="sd">    .. [3] https://hydra.cc/docs/next/advanced/instantiate_objects/overview/#parameter-conversion-strategies</span>
<span class="sd">    .. [4] https://hydra.cc/docs/next/tutorials/structured_config/intro/#structured-configs-supports</span>
<span class="sd">    .. [5] https://docs.python.org/3/library/dataclasses.html#default-factory-functions</span>
<span class="sd">    .. [6] https://docs.python.org/3/library/dataclasses.html#dataclasses.make_dataclass</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from hydra_zen import make_config, to_yaml</span>
<span class="sd">    &gt;&gt;&gt; def pp(x): return print(to_yaml(x))  # pretty-print config as yaml</span>

<span class="sd">    Let&#39;s create a bare-bones config with two fields, named &#39;a&#39; and &#39;b&#39;.</span>

<span class="sd">    &gt;&gt;&gt; Conf1 = make_config(&quot;a&quot;, &quot;b&quot;)  # sig: `Conf(a: Any, b: Any)`</span>
<span class="sd">    &gt;&gt;&gt; pp(Conf1)</span>
<span class="sd">    a: ???</span>
<span class="sd">    b: ???</span>

<span class="sd">    Now we&#39;ll configure these fields with particular values:</span>

<span class="sd">    &gt;&gt;&gt; pp(Conf1(1, &quot;hi&quot;))</span>
<span class="sd">    a: 1</span>
<span class="sd">    b: hi</span>

<span class="sd">    We can also specify fields via keyword args; this is especially convenient</span>
<span class="sd">    for providing associated default values.</span>

<span class="sd">    &gt;&gt;&gt; Conf2 = make_config(&quot;unit&quot;, data=[-10, -20])</span>
<span class="sd">    &gt;&gt;&gt; pp(Conf2)</span>
<span class="sd">    unit: ???</span>
<span class="sd">    data:</span>
<span class="sd">    - -10</span>
<span class="sd">    - -20</span>

<span class="sd">    Configurations can be nested</span>

<span class="sd">    &gt;&gt;&gt; Conf3 = make_config(c1=Conf1(a=1, b=2), c2=Conf2)</span>
<span class="sd">    &gt;&gt;&gt; pp(Conf3)</span>
<span class="sd">    c1:</span>
<span class="sd">      a: 1</span>
<span class="sd">      b: 2</span>
<span class="sd">    c2:</span>
<span class="sd">      unit: ???</span>
<span class="sd">      data:</span>
<span class="sd">      - -10</span>
<span class="sd">      - -20</span>
<span class="sd">    &gt;&gt;&gt; Conf3.c1.a</span>
<span class="sd">    1</span>

<span class="sd">    Configurations can be composed via inheritance</span>

<span class="sd">    &gt;&gt;&gt; pp(make_config(c=2, bases=(Conf2, Conf1)))</span>
<span class="sd">    a: ???</span>
<span class="sd">    b: ???</span>
<span class="sd">    unit: ???</span>
<span class="sd">    data:</span>
<span class="sd">    - -10</span>
<span class="sd">    - -20</span>
<span class="sd">    c: 2</span>

<span class="sd">    **Using ZenField to Provide Type Information**</span>

<span class="sd">    The `ZenField` class can be used to include a type-annotation in association</span>
<span class="sd">    with a field.</span>

<span class="sd">    &gt;&gt;&gt; from hydra_zen import ZenField as zf</span>
<span class="sd">    &gt;&gt;&gt; ProfileConf = make_config(username=zf(str), age=zf(int))</span>
<span class="sd">    &gt;&gt;&gt; # signature: ProfileConf(username: str, age: int)</span>

<span class="sd">    Providing type annotations is optional, but doing so enables Hydra to perform</span>
<span class="sd">    checks at runtime to ensure that a configured value matches its associated type [4]_.</span>

<span class="sd">    &gt;&gt;&gt; pp(ProfileConf(username=&quot;piro&quot;, age=False))  # age should be an integer</span>
<span class="sd">    &lt;ValidationError: Value &#39;False&#39; could not be converted to Integer&gt;</span>

<span class="sd">    These default values can be provides alongside type-annotations</span>

<span class="sd">    &gt;&gt;&gt; C = make_config(age=zf(int, 0))  # signature: C(age: int = 0)</span>

<span class="sd">    `ZenField` can also be used to specify ``fields_as_args``; here, field names</span>
<span class="sd">    must be specified as well.</span>

<span class="sd">    &gt;&gt;&gt; C2 = make_config(zf(name=&quot;username&quot;, hint=str), age=zf(int, 0))</span>
<span class="sd">    &gt;&gt;&gt; # signature: C2(username: str, age: int = 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">_field</span> <span class="ow">in</span> <span class="n">fields_as_args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_field</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`fields_as_args` can only consist of field-names (i.e. strings) or &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`ZenField` instances. Got: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fields_as_args</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">)))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_field</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_field</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;All `ZenField` instances specified in `fields_as_args` must have a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;name associated with it. Got: </span><span class="si">{</span><span class="n">_field</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_field</span> <span class="ow">in</span> <span class="n">fields_as_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_field</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_field</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span> <span class="ow">and</span> <span class="n">_field</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`fields_as_kwargs` specifies conflicting names: the kwarg </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;is associated with a `ZenField` with name </span><span class="si">{</span><span class="n">_field</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_field</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">if</span> <span class="n">fields_as_args</span><span class="p">:</span>
        <span class="n">all_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">)</span> <span class="k">else</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_as_args</span><span class="p">]</span>
        <span class="n">all_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fields_as_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_names</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`fields_as_args` cannot specify the same field-name multiple times.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; Got multiple entries for:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">all_names</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">_name</span> <span class="ow">in</span> <span class="n">all_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_zen_&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The field-name specified via `</span><span class="si">{</span><span class="n">_name</span><span class="si">}</span><span class="s2">=&lt;...&gt;` is reserved by hydra-zen.&quot;</span>
                    <span class="s2">&quot; You can manually create a dataclass to utilize this name in a structured config.&quot;</span>
                <span class="p">)</span>
        <span class="k">del</span> <span class="n">all_names</span>

    <span class="c1"># validate hydra-args via `builds`</span>
    <span class="c1"># also check for use of reserved names</span>
    <span class="n">builds</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">,</span>
        <span class="n">hydra_convert</span><span class="o">=</span><span class="n">hydra_convert</span><span class="p">,</span>
        <span class="n">hydra_recursive</span><span class="o">=</span><span class="n">hydra_recursive</span><span class="p">,</span>
        <span class="o">**</span><span class="n">fields_as_kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">normalized_fields</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">_field</span> <span class="ow">in</span> <span class="n">fields_as_args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_field</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">normalized_fields</span><span class="p">[</span><span class="n">_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZenField</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">_field</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="n">Any</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="n">normalized_fields</span><span class="p">[</span><span class="n">_field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_field</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fields_as_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ZenField</span><span class="p">):</span>
            <span class="n">normalized_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZenField</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalized_fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># fields without defaults must come first</span>
    <span class="n">config_fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">hint</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">normalized_fields</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">NOTHING</span>
    <span class="p">]</span>

    <span class="n">config_fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                <span class="p">(</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">hint</span>
                    <span class="c1"># f.default: Field</span>
                    <span class="c1"># f.default.default: Any</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_builds</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="ow">or</span> <span class="n">hydra_recursive</span> <span class="ow">is</span> <span class="kc">False</span>
                    <span class="k">else</span> <span class="n">Any</span>
                <span class="p">),</span>
                <span class="n">f</span><span class="o">.</span><span class="n">default</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">normalized_fields</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">hydra_recursive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_RECURSIVE_FIELD_NAME</span><span class="p">,</span>
                <span class="nb">bool</span><span class="p">,</span>
                <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">hydra_recursive</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">hydra_convert</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">_CONVERT_FIELD_NAME</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">hydra_convert</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
        <span class="n">Type</span><span class="p">[</span><span class="n">DataClass</span><span class="p">],</span>
        <span class="n">make_dataclass</span><span class="p">(</span>
            <span class="n">cls_name</span><span class="o">=</span><span class="n">config_name</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">config_fields</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="n">frozen</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">bases</span>
        <span class="p">),</span>
    <span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021 Massachusetts Institute of Technology.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>